"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Wait = void 0;

var _readline = _interopRequireDefault(require("readline"));

var _cliCommand = _interopRequireWildcard(require("@percy/cli-command"));

var _client = _interopRequireDefault(require("@percy/client"));

var _logger = _interopRequireDefault(require("@percy/logger"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Wait extends _cliCommand.default {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "log", (0, _logger.default)('cli:build:wait'));
  }

  async run() {
    if (!this.isPercyEnabled()) {
      this.log.info('Percy is disabled');
      return;
    }

    let client = new _client.default();
    let result = await client.waitForBuild({
      progress: this.progress,
      ...this.flags
    });
    return this.finish(result);
  } // Log build progress


  progress({
    attributes: {
      state,
      'total-snapshots': count,
      'total-comparisons': total,
      'total-comparisons-finished': finished
    }
  }) {
    // update the same line each time
    _readline.default.cursorTo(_logger.default.stdout, 0); // still recieving snapshots


    if (state === 'pending') {
      _logger.default.stdout.write(_logger.default.format('Recieving snapshots...', 'cli:build:wait')); // need to clear the line before finishing

    } else if (finished === total || state === 'finished') {
      _readline.default.clearLine(_logger.default.stdout);
    } // processing snapshots


    if (state === 'processing') {
      _logger.default.stdout.write(_logger.default.format(`Processing ${count} snapshots - ` + (finished === total ? 'finishing up...' : `${finished} of ${total} comparisons finished...`), 'cli:build:wait'));
    }
  } // Log build status


  finish({
    attributes: {
      state,
      'web-url': url,
      'build-number': number,
      'total-comparisons-diff': diffs,
      'failure-reason': failReason,
      'failure-details': failDetails
    }
  }) {
    if (state === 'finished') {
      this.log.info(`Build #${number} finished! ${url}`);
      this.log.info(`Found ${diffs} changes`);

      if (this.flags['fail-on-changes'] && diffs > 0) {
        return this.exit(1);
      }
    } else if (state === 'failed') {
      this.log.error(`Build #${number} failed! ${url}`);
      this.log.error(this.failure(failReason, failDetails));
      return this.exit(1);
    } else {
      this.log.error(`Build #${number} is ${state}. ${url}`);
      return this.exit(1);
    }
  } // Create failure messages


  failure(type, details) {
    switch (type) {
      case 'render_timeout':
        return 'Some snapshots in this build took too long to render even ' + 'after multiple retries.';

      case 'no_snapshots':
        return 'No snapshots were uploaded to this build.';

      case 'missing_finalize':
        return 'Failed to correctly finalize.';

      case 'missing_resources':
        // eslint-disable-next-line camelcase
        return details !== null && details !== void 0 && details.missing_parallel_builds ? `Only ${details.parallel_builds_received} of ` + `${details.parallel_builds_expected} parallelized build processes finished.` : 'Some build or snapshot resources failed to correctly upload.';

      default:
        return `Error: ${type}`;
    }
  }

}

exports.Wait = Wait;

_defineProperty(Wait, "description", 'Wait for a build to be finished. Requires a full access PERCY_TOKEN');

_defineProperty(Wait, "flags", { ..._cliCommand.flags.logging,
  build: _cliCommand.flags.string({
    char: 'b',
    description: 'build id',
    exclusive: ['project', 'commit']
  }),
  project: _cliCommand.flags.string({
    char: 'p',
    description: "build's project slug, required with --commit",
    inclusive: ['commit']
  }),
  commit: _cliCommand.flags.string({
    char: 'c',
    description: "build's commit sha for a project",
    inclusive: ['project']
  }),
  timeout: _cliCommand.flags.integer({
    char: 't',
    description: ['timeout, in milliseconds, to exit when there are no updates, ', 'defaults to 10 minutes'].join('')
  }),
  interval: _cliCommand.flags.integer({
    char: 'i',
    description: ['interval, in milliseconds, at which to poll for updates, ', 'defaults to 1000'].join('')
  }),
  'fail-on-changes': _cliCommand.flags.boolean({
    char: 'f',
    default: false,
    description: 'exits with an error when diffs are found in snapshots'
  })
});

_defineProperty(Wait, "examples", ['$ percy build:wait --build 2222222', '$ percy build:wait --project org/project --commit HEAD']);