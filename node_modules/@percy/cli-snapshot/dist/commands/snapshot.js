"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Snapshot = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _cliCommand = _interopRequireWildcard(require("@percy/cli-command"));

var _core = _interopRequireDefault(require("@percy/core"));

var _logger = _interopRequireDefault(require("@percy/logger"));

var _globby = _interopRequireDefault(require("globby"));

var _yaml = _interopRequireDefault(require("yaml"));

var _config = require("../config");

var _package = _interopRequireDefault(require("../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Snapshot extends _cliCommand.default {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "log", (0, _logger.default)('cli:snapshot'));
  }

  async run() {
    if (!this.isPercyEnabled()) {
      this.log.info('Percy is disabled. Skipping snapshots');
      return;
    }

    let config = this.percyrc();
    let {
      pathname
    } = this.args;

    if (!_fs.default.existsSync(pathname)) {
      return this.error(`Not found: ${pathname}`);
    } else if (config.static.baseUrl[0] !== '/') {
      return this.error('The base-url flag must begin with a forward slash (/)');
    }

    let pages = _fs.default.lstatSync(pathname).isDirectory() ? await this.loadStaticPages(pathname, config.static) : await this.loadPagesFile(pathname);

    if (!pages.length) {
      return this.error('No snapshots found');
    }

    if (this.flags['dry-run']) {
      let l = pages.length;
      return this.log.info(`Found ${l} snapshot${l === 1 ? '' : 's'}:\n` + pages.map(({
        name,
        snapshots = []
      }) => {
        return (name ? [{
          name
        }].concat(snapshots) : snapshots).map(({
          name
        }) => name).join('\n');
      }).join('\n'));
    }

    this.percy = await _core.default.start({
      clientInfo: `${_package.default.name}/${_package.default.version}`,
      server: false,
      config: false,
      ...config
    });
    await Promise.all(pages.map(page => this.percy.capture(page)));
  } // Called on error, interupt, or after running


  async finally() {
    var _this$percy;

    await ((_this$percy = this.percy) === null || _this$percy === void 0 ? void 0 : _this$percy.stop());

    if (this.server) {
      await new Promise(resolve => {
        this.server.close(resolve);
      });
    }
  } // Serves a static directory at a base-url and resolves when listening.


  async serve(staticDir, baseUrl) {
    let http = require('http');

    let serve = require('serve-handler');

    return new Promise(resolve => {
      this.server = http.createServer((req, res) => {
        serve(req, res, {
          public: staticDir
        });
      }).listen(() => {
        let {
          port
        } = this.server.address();
        resolve(`http://localhost:${port}`);
      });
    });
  } // Starts a static server and returns a list of pages to snapshot.


  async loadStaticPages(pathname, {
    baseUrl,
    files,
    ignore
  }) {
    ignore = [].concat(ignore).filter(Boolean);
    let paths = await (0, _globby.default)(files, {
      cwd: pathname,
      ignore
    });
    let addr = '';

    if (!this.flags['dry-run']) {
      addr = await this.serve(pathname, baseUrl);
    }

    return paths.sort().map(path => ({
      url: `${addr}${baseUrl}${path}`,
      name: `${baseUrl}${path}`
    }));
  } // Loads pages to snapshot from a js, json, or yaml file.


  async loadPagesFile(pathname) {
    let ext = _path.default.extname(pathname);

    if (ext === '.js') {
      let pages = require(_path.default.resolve(pathname));

      return typeof pages === 'function' ? await pages() : pages;
    } else if (ext === '.json') {
      return JSON.parse(_fs.default.readFileSync(pathname, {
        encoding: 'utf-8'
      }));
    } else if (ext.match(/\.ya?ml$/)) {
      return _yaml.default.parse(_fs.default.readFileSync(pathname, {
        encoding: 'utf-8'
      }));
    } else {
      return this.error(`Unsupported filetype: ${pathname}`);
    }
  }

}

exports.Snapshot = Snapshot;

_defineProperty(Snapshot, "description", 'Snapshot a list of pages from a file or directory');

_defineProperty(Snapshot, "args", [{
  name: 'pathname',
  description: 'path to a directory or file containing a list of pages',
  required: true
}]);

_defineProperty(Snapshot, "flags", { ..._cliCommand.flags.logging,
  ..._cliCommand.flags.discovery,
  ..._cliCommand.flags.config,
  'base-url': _cliCommand.flags.string({
    char: 'b',
    description: 'the url path to serve the static directory from',
    default: _config.schema.static.properties.baseUrl.default,
    percyrc: 'static.baseUrl'
  }),
  files: _cliCommand.flags.string({
    char: 'f',
    multiple: true,
    description: 'one or more globs matching static file paths to snapshot',
    default: _config.schema.static.properties.files.default,
    percyrc: 'static.files'
  }),
  ignore: _cliCommand.flags.string({
    char: 'i',
    multiple: true,
    description: 'one or more globs matching static file paths to ignore',
    percyrc: 'static.ignore'
  }),
  'dry-run': _cliCommand.flags.boolean({
    char: 'd',
    description: 'prints a list of pages to snapshot without snapshotting'
  })
});

_defineProperty(Snapshot, "examples", ['$ percy snapshot ./public', '$ percy snapshot pages.yml']);