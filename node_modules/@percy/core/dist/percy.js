"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _fs = require("fs");

var _client = _interopRequireDefault(require("@percy/client"));

var _config = _interopRequireDefault(require("@percy/config"));

var _logger = _interopRequireDefault(require("@percy/logger"));

var _queue = _interopRequireDefault(require("./queue"));

var _discoverer = _interopRequireDefault(require("./discovery/discoverer"));

var _server = _interopRequireDefault(require("./server"));

var _assert = _interopRequireDefault(require("./utils/assert"));

var _percyCss = _interopRequireDefault(require("./utils/percy-css"));

var _resources = require("./utils/resources");

var _url = require("./utils/url");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }

var _captures = new WeakMap();

var _snapshots = new WeakMap();

var _stopping = new WeakMap();

var _running = new WeakMap();

// A Percy instance will create a new build when started, handle snapshot
// creation, asset discovery, and resource uploads, and will finalize the build
// when stopped. Snapshots are processed concurrently and the build is not
// finalized until all snapshots have been handled.
class Percy {
  // Static shortcut to create and start an instance in one call
  static async start(options) {
    let instance = new this(options);
    await instance.start();
    return instance;
  }

  constructor({
    // provided to @percy/client
    token,
    clientInfo = '',
    environmentInfo = '',
    // snapshot server options
    server = true,
    port = 5338,
    // capture concurrency
    concurrency = 5,
    // initial log level
    loglevel,
    // configuration filepath
    config,
    // options such as `snapshot` and `discovery` that are valid Percy config
    // options which will become accessible via the `#config` property
    ...options
  } = {}) {
    _defineProperty(this, "log", (0, _logger.default)('core'));

    _captures.set(this, {
      writable: true,
      value: null
    });

    _snapshots.set(this, {
      writable: true,
      value: null
    });

    _stopping.set(this, {
      writable: true,
      value: false
    });

    _running.set(this, {
      writable: true,
      value: false
    });

    if (loglevel) {
      this.loglevel(loglevel);
    }

    if (server) {
      this.port = port;
      this.server = (0, _server.default)(this);
    }

    _classPrivateFieldSet(this, _snapshots, new _queue.default());

    _classPrivateFieldSet(this, _captures, new _queue.default(concurrency));

    this.config = config === false ? _config.default.getDefaults(options) : _config.default.load({
      path: config,
      overrides: options
    });
    this.discoverer = new _discoverer.default(this.config.discovery);
    this.client = new _client.default({
      token,
      clientInfo,
      environmentInfo
    });
  } // Shortcut for controlling the global logger's log level.


  loglevel(level) {
    return _logger.default.loglevel(level);
  } // Snapshot server API address


  address() {
    return `http://localhost:${this.port}`;
  } // Returns a boolean indicating if this instance is running.


  isRunning() {
    return _classPrivateFieldGet(this, _running);
  } // Starts the local API server, the asset discovery process, and creates a new
  // Percy build. When an error is encountered, the discoverer and server are closed.


  async start() {
    // throws when the token is missing
    this.client.getToken();

    try {
      var _this$server;

      // launch the discoverer browser and create a percy build
      await this.discoverer.launch();
      await this.client.createBuild(); // if there is a server, start listening

      await ((_this$server = this.server) === null || _this$server === void 0 ? void 0 : _this$server.listen(this.port)); // log build details

      let build = this.client.build;
      let meta = {
        build: {
          id: build.id
        }
      };
      this.log.info('Percy has started!', meta);
      this.log.info(`Created build #${build.number}: ${build.url}`, meta); // mark this process as running

      _classPrivateFieldSet(this, _running, true);
    } catch (error) {
      var _this$server2;

      // on error, close any running server or browser
      await ((_this$server2 = this.server) === null || _this$server2 === void 0 ? void 0 : _this$server2.close());
      await this.discoverer.close(); // throw an easier-to understand error when the port is taken

      if (error.code === 'EADDRINUSE') {
        throw new Error('Percy is already running or the port is in use');
      } else {
        throw error;
      }
    }
  } // Stops the local API server and discoverer once snapshots have completed and
  // finalizes the Percy build. Does nothing if not running.


  async stop() {
    // do nothing if not running or already stopping
    if (this.isRunning() && !_classPrivateFieldGet(this, _stopping)) {
      var _this$server3;

      _classPrivateFieldSet(this, _stopping, true);

      let build = this.client.build;
      let meta = {
        build: {
          id: build.id
        }
      };
      this.log.info('Stopping percy...', meta); // log about queued captures or uploads

      if (_classPrivateFieldGet(this, _captures).length) {
        this.log.info(`Waiting for ${_classPrivateFieldGet(this, _captures).length} page(s) to finish snapshotting`, meta);
      } else if (_classPrivateFieldGet(this, _snapshots).length) {
        this.log.info(`Waiting for ${_classPrivateFieldGet(this, _snapshots).length} snapshot(s) to finish uploading`, meta);
      } // wait for any queued captures or snapshots


      await this.idle();

      _classPrivateFieldSet(this, _running, false); // close the discoverer and server


      await this.discoverer.close();
      await ((_this$server3 = this.server) === null || _this$server3 === void 0 ? void 0 : _this$server3.close()); // finalize the build

      await this.client.finalizeBuild();
      this.log.info(`Finalized build #${build.number}: ${build.url}`, meta);
      this.log.info('Done!');
    }
  } // Resolves when captures and snapshots are idle.


  async idle() {
    await Promise.all([_classPrivateFieldGet(this, _captures).idle(), _classPrivateFieldGet(this, _snapshots).idle()]);
  } // Handles asset discovery for the URL and DOM snapshot at each requested
  // width with the provided options. Resolves when the snapshot has been taken
  // and asset discovery is finished, but does not gaurantee that the snapshot
  // will be succesfully uploaded.


  snapshot({
    url,
    name,
    domSnapshot,
    widths,
    minHeight,
    percyCSS,
    enableJavaScript,
    clientInfo,
    environmentInfo,
    discovery = {},
    ...deprecated
  }) {
    var _widths, _widths2, _minHeight, _ref, _enableJavaScript;

    // required assertions
    (0, _assert.default)(this.isRunning(), 'Not running');
    (0, _assert.default)(url, 'Missing required argument: url');
    (0, _assert.default)(name, 'Missing required argument: name');
    (0, _assert.default)(domSnapshot, 'Missing required argument: domSnapshot'); // fallback to instance snapshot widths

    widths = (_widths = widths) !== null && _widths !== void 0 && _widths.length ? widths : this.config.snapshot.widths;
    (0, _assert.default)((_widths2 = widths) === null || _widths2 === void 0 ? void 0 : _widths2.length, 'Missing required argument: widths');
    (0, _assert.default)(widths.length <= 10, 'too many widths'); // normalize the URL

    url = (0, _url.normalizeURL)(url); // fallback to instance minimum height

    minHeight = (_minHeight = minHeight) !== null && _minHeight !== void 0 ? _minHeight : this.config.snapshot.minHeight; // combine snapshot Percy CSS with instance Percy CSS

    percyCSS = [this.config.snapshot.percyCSS, percyCSS].filter(Boolean).join('\n'); // fallback to instance enable JS flag

    enableJavaScript = (_ref = (_enableJavaScript = enableJavaScript) !== null && _enableJavaScript !== void 0 ? _enableJavaScript : this.config.snapshot.enableJavaScript) !== null && _ref !== void 0 ? _ref : false; // discovery options have moved

    for (let k of ['authorization', 'requestHeaders']) {
      if (deprecated[k]) {
        this.log.warn(`Warning: The snapshot option \`${k}\` will be removed in 1.0.0. ` + `Use \`discovery.${k}\` instead.`);
        discovery[k] = deprecated[k];
      }
    } // useful meta info for the logfile


    let meta = {
      snapshot: {
        name
      },
      build: {
        id: this.client.build.id
      }
    };
    this.log.debug('---------');
    this.log.debug('Handling snapshot:', meta);
    this.log.debug(`-> name: ${name}`, meta);
    this.log.debug(`-> url: ${url}`, meta);
    this.log.debug(`-> widths: ${widths.join('px, ')}px`, meta);
    this.log.debug(`-> minHeight: ${minHeight}px`, meta);
    this.log.debug(`-> enableJavaScript: ${enableJavaScript}`, meta);
    this.log.debug(`-> discovery: ${JSON.stringify(discovery)}`, meta);
    this.log.debug(`-> clientInfo: ${clientInfo}`, meta);
    this.log.debug(`-> environmentInfo: ${environmentInfo}`, meta);
    this.log.debug(`-> domSnapshot:\n${domSnapshot.length <= 1024 ? domSnapshot : domSnapshot.substr(0, 1024) + '... [truncated]'}`, meta); // use a promise as a try-catch so we can do the remaining work
    // asynchronously, but perform the above synchronously

    return Promise.resolve().then(async () => {
      // inject Percy CSS
      let [percyDOM, percyCSSResource] = (0, _percyCss.default)(url, domSnapshot, percyCSS, meta); // use a map so resources remain unique by url

      let resources = new Map([[url, (0, _resources.createRootResource)(url, percyDOM)]]); // include the Percy CSS resource if there was one

      if (percyCSSResource) resources.set('percy-css', percyCSSResource); // gather resources at each width concurrently

      await Promise.all(widths.map(width => this.discoverer.gatherResources({ ...discovery,
        onDiscovery: r => resources.set(r.url, r),
        rootUrl: url,
        rootDom: domSnapshot,
        enableJavaScript,
        width,
        meta
      }))); // include a log resource for debugging

      let logs = _logger.default.query(({
        meta
      }) => {
        var _meta$snapshot;

        return ((_meta$snapshot = meta.snapshot) === null || _meta$snapshot === void 0 ? void 0 : _meta$snapshot.name) === name;
      });

      resources.set('percy-logs', (0, _resources.createLogResource)(logs)); // log that the snapshot has been taken before uploading it

      this.log.info(`Snapshot taken: ${name}`, meta); // upload within the async snapshot queue

      _classPrivateFieldGet(this, _snapshots).push(() => this.client.sendSnapshot({
        name,
        widths,
        minHeight,
        enableJavaScript,
        clientInfo,
        environmentInfo,
        resources: Array.from(resources.values())
      }).catch(error => {
        this.log.error(`Encountered an error uploading snapshot: ${name}`, meta);
        this.log.error(error);
      }));
    }).catch(error => {
      this.log.error(`Encountered an error taking snapshot: ${name}`, meta);
      this.log.error(error);
    });
  }

  capture({
    url,
    name,
    waitForTimeout,
    waitForSelector,
    execute,
    snapshots = [],
    ...options
  }) {
    (0, _assert.default)(this.isRunning(), 'Not running');
    (0, _assert.default)(url, `Missing URL for${name ? ` ${name}` : ' snapshots'}`);
    snapshots = name ? [{
      name,
      execute
    }].concat(snapshots) : snapshots;
    (0, _assert.default)(snapshots.length && snapshots.every(s => s.name), `Missing name for ${url}`); // the entire capture process happens within the async capture queue

    return _classPrivateFieldGet(this, _captures).push(async () => {
      let meta = {
        snapshot: {
          name,
          waitForTimeout,
          waitForSelector
        }
      };
      let results = [];
      let page; // discovery options have moved, a warning will be logged during the snapshot phase

      let {
        requestHeaders,
        authorization
      } = options;
      options.discovery || (options.discovery = {
        requestHeaders,
        authorization
      });
      this.log.debug('---------');
      this.log.debug('Handling page capture:', meta);
      this.log.debug(`-> url: ${url}`, meta);
      this.log.debug(`-> name: ${url}`, meta);
      this.log.debug(`-> waitForTimeout: ${waitForTimeout}`, meta);
      this.log.debug(`-> waitForSelector: ${waitForSelector}`, meta);
      this.log.debug(`-> execute: ${execute}`, meta);

      try {
        // borrow a page from the discoverer
        page = await this.discoverer.page(options.discovery); // navigate to the page and wait until ready

        await page.goto(url, {
          waitForTimeout,
          waitForSelector
        }); // multiple snapshots can be captured on a single page

        for (let {
          name,
          execute
        } of snapshots) {
          if (execute) {
            this.log.debug('Executing JavaScript', { ...meta,
              execute
            }); // accept function bodies as strings

            if (typeof execute === 'string') execute = `async execute({ waitFor }) {\n${execute}\n}`; // execute the provided function

            await page.eval(execute); // may cause additional network activity

            await page.network.idle();
          } // inject @percy/dom for serialization by evaluating the file contents which adds a global
          // PercyDOM object that we can later check against

          /* istanbul ignore next: no instrumenting injected code */


          if (await page.eval(() => !window.PercyDOM)) {
            this.log.debug('Injecting @percy/dom', meta);
            let script = await _fs.promises.readFile(require.resolve('@percy/dom'), 'utf-8');
            /* eslint-disable-next-line no-new-func */

            await page.eval(new Function(script));
          } // serialize and capture a DOM snapshot


          this.log.debug('Serializing DOM', meta);
          /* istanbul ignore next: no instrumenting injected code */

          let {
            url,
            domSnapshot
          } = await page.eval(({
            enableJavaScript
          }) => ({
            /* eslint-disable-next-line no-undef */
            domSnapshot: PercyDOM.serialize({
              enableJavaScript
            }),
            url: document.URL
          }), options); // snapshots are awaited on concurrently after sequentially capturing their DOM

          results.push(this.snapshot({ ...options,
            url,
            name,
            domSnapshot
          }));
        }
      } catch (error) {
        // handle errors
        this.log.error(`Encountered an error for page: ${url}`, meta);
        this.log.error(error, meta);
      } finally {
        var _page;

        // close the page
        await ((_page = page) === null || _page === void 0 ? void 0 : _page.close()); // await on any resulting snapshots

        await Promise.all(results);
      }
    });
  }

}

exports.default = Percy;