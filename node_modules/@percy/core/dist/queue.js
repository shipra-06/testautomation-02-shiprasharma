"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _waitFor = _interopRequireDefault(require("./utils/wait-for"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }

function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

var _queue = new WeakMap();

var _pending = new WeakMap();

// Concurrent task-based queue for handling snapshots and asset discovery.
class Queue {
  // Defaults to inifinite concurrency
  constructor(concurrency = Infinity) {
    _queue.set(this, {
      writable: true,
      value: []
    });

    _pending.set(this, {
      writable: true,
      value: 0
    });

    this.concurrency = concurrency;
  } // Pushing a new task to the queue will attempt to run it unless the
  // concurrency limit has been reached. The returned promise will resolve or
  // reject when the task has succeeded or thrown an error.


  push(task) {
    return new Promise((resolve, reject) => {
      _classPrivateFieldGet(this, _queue).push({
        task,
        resolve,
        reject
      });

      this._dequeue();
    });
  } // Returns the amount of queued and pending tasks.


  get length() {
    return _classPrivateFieldGet(this, _queue).length + _classPrivateFieldGet(this, _pending);
  } // Resolves when there are no more queued or pending tasks.


  idle() {
    return (0, _waitFor.default)(() => this.length === 0, {
      timeout: 2 * 60 * 1000 // 2 minutes

    });
  } // Clears the active queue. Tasks that were queued will not be executed and
  // tasks that are pending (have already executed) will be allowed to finish.


  clear() {
    _classPrivateFieldSet(this, _queue, []);

    return this.length;
  } // Begins processing the queue by running the oldest task first. Pending tasks
  // are tracked and no tasks will run unless there are less pending than the
  // concurrency limit. More tasks are dequeued when the current task
  // finishes. Resolves when the current task finishes although this method
  // should never be awaited on so multiple tasks can run concurrently.


  async _dequeue() {
    var _this$pending;

    if (_classPrivateFieldGet(this, _pending) >= this.concurrency) return;

    let item = _classPrivateFieldGet(this, _queue).shift();

    if (!item) return;
    _classPrivateFieldSet(this, _pending, (_this$pending = +_classPrivateFieldGet(this, _pending)) + 1), _this$pending;

    try {
      var _this$pending2;

      let value = await item.task();
      _classPrivateFieldSet(this, _pending, (_this$pending2 = +_classPrivateFieldGet(this, _pending)) - 1), _this$pending2;
      item.resolve(value);
    } catch (error) {
      var _this$pending3;

      _classPrivateFieldSet(this, _pending, (_this$pending3 = +_classPrivateFieldGet(this, _pending)) - 1), _this$pending3;
      item.reject(error);
    } finally {
      this._dequeue();
    }
  }

}

exports.default = Queue;