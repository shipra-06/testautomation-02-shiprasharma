"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _logger = _interopRequireDefault(require("@percy/logger"));

var _queue = _interopRequireDefault(require("../queue"));

var _assert = _interopRequireDefault(require("../utils/assert"));

var _resources = require("../utils/resources");

var _url = require("../utils/url");

var _browser = _interopRequireDefault(require("./browser"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

const ALLOWED_STATUSES = [200, 201, 301, 302, 304, 307, 308]; // A PercyDiscoverer instance connects to a browser process and concurrently discovers resources
// for snapshots. Resources are only captured from the snapshot's root URL by default unless
// additional allowed hostnames are defined. Captured resources are cached so future requests
// resolve much quicker and snapshots can share cached resources.

var _cache = new WeakMap();

class PercyDiscoverer {
  constructor({
    concurrency = 5,
    ...config
  }) {
    _defineProperty(this, "queue", null);

    _defineProperty(this, "browser", null);

    _defineProperty(this, "log", (0, _logger.default)('core:discovery'));

    _cache.set(this, {
      writable: true,
      value: new Map()
    });

    this.queue = new _queue.default(concurrency);
    this.browser = new _browser.default();
    this.config = config;
  } // Installs the browser executable if necessary then launches and connects to a browser process.


  async launch() {
    await this.browser.launch(this.config.launchOptions);
  } // Returns true or false when the browser is connected.


  isConnected() {
    return this.browser.isConnected();
  } // Clears any unstarted discovery tasks and closes the browser.


  async close() {
    this.queue.clear();
    await this.browser.close();
  } // Returns a new browser page.


  async page(options) {
    let {
      requestHeaders,
      authorization,
      networkIdleTimeout
    } = this.config;
    return this.browser.page({ ...options,
      requestHeaders: { ...requestHeaders,
        ...options.requestHeaders
      },
      authorization: { ...authorization,
        ...options.authorization
      },
      networkIdleTimeout
    });
  } // Gathers resources for a root URL and DOM. The `onDiscovery` callback will be called whenever an
  // asset is requested. The returned promise resolves when asset discovery finishes.


  gatherResources(options) {
    (0, _assert.default)(this.isConnected(), 'Browser not connected'); // discover assets concurrently

    return this.queue.push(async () => {
      let {
        width,
        rootUrl: url,
        meta
      } = options;
      let page;
      this.log.debug(`Discovering resources @${width}px for ${url}`, { ...meta,
        url
      });

      try {
        // get a fresh page
        page = await this.page({ ...options,
          cacheDisabled: true
        }); // set up request interception

        page.network.onrequest = this._handleRequest(options);
        page.network.onrequestfinished = this._handleRequestFinished(options);
        page.network.onrequestfailed = this._handleRequestFailed(options);
        await page.network.intercept(); // navigate to the root URL and wait for the network to idle

        await page.goto(url);
      } finally {
        var _page;

        // safely close the page
        await ((_page = page) === null || _page === void 0 ? void 0 : _page.close());
      }
    });
  } // Creates a request handler for the specific root URL and DOM. The handler will serve the root
  // DOM for the root URL, respond with possible cached responses, skip resources that should not be
  // captured, and abort requests that result in an error.


  _handleRequest({
    meta,
    rootUrl,
    rootDom,
    disableCache,
    allowedHostnames
  }) {
    let rootHost = (0, _url.hostname)(rootUrl);
    return async request => {
      let url = request.url;
      meta = { ...meta,
        url
      };
      this.log.debug(`Handling request for ${url}`, meta);

      try {
        if (url === rootUrl) {
          // root resource
          this.log.debug(`Serving root resource for ${url}`, meta);
          await request.respond({
            status: 200,
            body: rootDom,
            headers: {
              'content-type': 'text/html'
            }
          });
        } else if (!disableCache && !this.config.disableCache && _classPrivateFieldGet(this, _cache).has(url)) {
          // respond with cached response
          this.log.debug(`Response cache hit for ${url}`, meta);
          await request.respond(_classPrivateFieldGet(this, _cache).get(url).response);
        } else {
          // do not resolve resources that should not be captured
          (0, _assert.default)((0, _url.domainMatch)(rootHost, url) || (0, _url.domainMatch)(allowedHostnames, url) || (0, _url.domainMatch)(this.config.allowedHostnames, url), 'is remote', meta);
          await request.continue();
        }
      } catch (error) {
        if (error.name === 'PercyAssertionError') {
          this.log.debug(`Skipping - ${error.toString()}`, error.meta);
          await request.abort();
        } else {
          this.log.debug(`Encountered an error handling request: ${url}`, meta);
          this.log.debug(error);
          await request.abort(error);
        }
      }
    };
  } // Creates a request finished handler for a specific root URL to discover resolved resources. Both
  // the response and resource are cached for future snapshots and requests.


  _handleRequestFinished({
    meta,
    rootUrl,
    onDiscovery,
    disableCache
  }) {
    return async request => {
      let origin = request.redirectChain[0] || request;
      let url = (0, _url.normalizeURL)(origin.url);
      meta = { ...meta,
        url
      }; // do nothing for the root URL

      if (url === rootUrl) return;

      try {
        // process and cache the response and resource
        if (disableCache || this.config.disableCache || !_classPrivateFieldGet(this, _cache).has(url)) {
          this.log.debug(`Processing resource - ${url}`, meta); // get and validate response

          let response = request.response;
          (0, _assert.default)(response, 'no response', meta); // get and validate status

          let status = response.status;
          (0, _assert.default)(ALLOWED_STATUSES.includes(status), 'disallowed status', { ...meta,
            status
          }); // 'Network.responseReceived' returns multiple headers joined by newlines, however
          // `Fetch.fulfillRequest` (used for cached responses) will hang if there are newlines in
          // headers. The following reduction normalizes header values as arrays split on newlines

          let headers = Object.entries(response.headers).reduce((norm, [key, value]) => {
            return Object.assign(norm, {
              [key]: value.split('\n')
            });
          }, {}); // get and validate body

          let body = await response.buffer();
          (0, _assert.default)(body.toString(), 'is empty', meta); // create a local resource and log its info

          let resource = (0, _resources.createLocalResource)(url, body, response.mimeType, () => {
            this.log.debug(`Making local copy of response - ${url}`, meta);
          });
          this.log.debug(`-> url: ${url}`, meta);
          this.log.debug(`-> sha: ${resource.sha}`, meta);
          this.log.debug(`-> filepath: ${resource.filepath}`, meta);
          this.log.debug(`-> mimetype: ${resource.mimetype}`, meta); // cache both the response and resource

          response = {
            status,
            headers,
            body
          };

          _classPrivateFieldGet(this, _cache).set(url, {
            response,
            resource
          });
        } // call `onDiscovery` with the resource


        onDiscovery(_classPrivateFieldGet(this, _cache).get(url).resource);
      } catch (error) {
        if (error.name === 'PercyAssertionError') {
          this.log.debug(`Skipping - ${error.toString()}`, error.meta);
        } else {
          this.log.debug(`Encountered an error processing resource: ${url}`, meta);
          this.log.debug(error);
        }
      }
    };
  } // Creates a failed request handler that logs non-generic failure reasons.


  _handleRequestFailed({
    meta
  }) {
    return request => {
      let {
        url,
        error
      } = request; // do not log generic failures since the real error was most likely
      // already logged from elsewhere

      if (error !== 'net::ERR_FAILED') {
        this.log.debug(`Request failed for ${url}: ${error}`, { ...meta,
          url
        });
      }
    };
  }

}

exports.default = PercyDiscoverer;